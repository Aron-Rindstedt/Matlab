function [L2norm,v,mov] = pol2D(boundType,stepType,testType,NL)
    
%%%%% Setup
% boundType = 0; %0=Neumann, 1=Dirichlet
% stepType = 0;  %0=RK4, 1=2nd order stepping
%N = 100;
%CFL = 0;
    
    movTime = 2;
    L2Test=0;
    eigTest=0;
    errTest=0;
    tEnd = 2*pi;
    switch testType
      case 1
        eigTest=1;
      case 2
        L2Test=1;
        tEnd=1;
      case 3
        errTest=1;
      case 4
        movTime=0;
      case 5
        tEnd=pi/10;
        movTime=0;
    end

    [u_x,v_x,u_y,v_y] = u_vars();
    u_t = sqrt(u_x^2+u_y^2);
    
    function out = f(x,y,t)
        out = kron(sin(u_x*x+v_x),sin(u_y*y+v_y))*cos(u_t*t);
    end
    function out = f_x(x,y,t)
        out = kron(u_x*cos(u_x*x+v_x),sin(u_y*y+v_y))*cos(u_t*t);
    end
    function out = f_y(x,y,t)
        out = kron(sin(u_x*x+v_x),u_y*cos(u_y*y+v_y))*cos(u_t*t);
    end
    function out = f_t(x,y,t)
        out = kron(sin(u_x*x+v_x),sin(u_y*y+v_y))*-u_t*sin(u_t*t);
    end
    
    %Based on assumptions within interpolation generator.
    if mod(NL,2)==1
        error('NL must be divisible by two');
    end
    NR = NL/2;
    deriv = @HOM4_D_VAR_NARROW;
    [polLR,polRL] = Interpolation_4(NR+1);
    polLR = sparse(polLR);
    polRL = sparse(polRL);

    CFL = 30;  %Quick-n-dirty CFL-numbers. Probably won't work if
               %b,c ~= 1
    movN = movTime*30;

    t = 0;

    xmin = 0;
    xmid = pi;
    xmax = 2*pi;

    ymin = 0;
    ymax = pi;

    xL = linspace(xmin,xmid, NL+1)';
    xR = linspace(xmid,xmax, NR+1)';
    yL = linspace(ymin,ymax, NL+1)';
    yR = linspace(ymin,ymax, NR+1)';
    hL = xL(2)-xL(1);
    hR = xR(2)-xR(1);
    
    dt = min([hL hR])/CFL;
    M = ceil(tEnd/dt);
    dt = tEnd/M;

    v = 0;
    v_prev = 0;
    if stepType==0
        v = [f(xL,yL,t); f(xR,yR,t); f_t(xL,yL,t); f_t(xR,yR,t)];
    end
    if stepType==1
        v = [f(xL,yL,t); f(xR,yR,t)];
        v_prev = [f(xL,yL,t-dt); f(xR,yR,t-dt)];
    end
    
    function out = bL(x)
        out = ones(size(x));
    end
    
    function out = bR(x)
        out = ones(size(x));
    end

    function out = cL(y)
        out = ones(size(y));
    end
    function out = cR(y)
        out = ones(size(y));
    end
    
    %%Autogenerated boundaries
    function out = N_g0(y,t)
        out = f_x(xmin,y,t);
    end
    function out = N_g1(y,t)
        out = f_x(xmax,y,t);
    end
    function out = N_g2(x,t)
        out = f_y(x,ymin,t);
    end
    function out = N_g3(x,t)
        out = f_y(x,ymax,t);
    end
    
    function out = D_g0(y,t)
        out = f(xmin,y,t);
    end
    function out = D_g1(y,t)
        out = f(xmax,y,t);
    end
    function out = D_g2(x,t)
        out = f(x,ymin,t);
    end
    function out = D_g3(x,t)
        out = f(x,ymax,t);
    end
    
    if boundType==0
        g0 = @N_g0;
        g1 = @N_g1;
        g2L = @N_g2;
        g2R = @N_g2;
        g3L = @N_g3;
        g3R = @N_g3;
    end
    
    if boundType==1
        g0 = @D_g0;
        g1 = @D_g1;
        g2L = @D_g2;
        g2R = @D_g2;
        g3L = @D_g3;
        g3R = @D_g3;
    end
    
    bigNL = (NL+1)^2;
    bigNR = (NR+1)^2;
    bigbigN = bigNL+bigNR;
    
    mov = zeros(bigbigN,movN);
    movT = 0;
    movDt = tEnd/movN;
    movK = 1;
    
    gamma = 5; %Dirichlet tuning variable

    %%%%% Operator creation
    %alph = 0.2508560249; %For fourth-order operators
    alph = 0.1878715026;  %For sixth-order operators
    IL = sparse(eye(NL+1));
    IR = sparse(eye(NR+1));
    [HIL,~,D2xL,BSxL] = deriv(NL+1,hL,bL(xL));
    [HIR,~,D2xR,BSxR] = deriv(NR+1,hR,bR(xR));
    [~  ,~,D2yL,BSyL] = deriv(NL+1,hL,cL(yL));
    [~  ,~,D2yR,BSyR] = deriv(NR+1,hR,cR(yR));
    % [H,~,D2,BS] = SBP8(N+1,h);
    % HI = inv(H);
    HIL = sparse(HIL);
    HIR = sparse(HIR);
    e0L = sparse(  1,1,1,NL+1,1);
    e0R = sparse(  1,1,1,NR+1,1);
    eNL = sparse(NL+1,1,1,NL+1,1);
    eNR = sparse(NR+1,1,1,NR+1,1);
    He0L = HIL*e0L;
    He0R = HIR*e0R;
    HeNL = HIL*eNL;
    HeNR = HIR*eNR;
    big0LR = sparse(bigNL,bigNR);
    big0RL = sparse(bigNR,bigNL);
    
    %Extra pieces for prim1 and bis1
    bigHIxL = kron(HIL,IL);
    bigHIxR = kron(HIR,IR);
    bigbigHIx = [bigHIxL big0LR; big0RL bigHIxR];
    bigHIyL = kron(IL,HIL);
    bigHIyR = kron(IR,HIR);
    bigbigHIy = [bigHIyL big0LR; big0RL bigHIyR];

    bigD2xL = kron(D2xL,IL);
    bigD2xR = kron(D2xR,IR);
    bigD2yL = kron(IL,D2yL);
    bigD2yR = kron(IR,D2yR);
    
    if boundType==0
        SATxL = kron(-1*HIL*(e0L*e0L')*BSxL,IL);
        SATxR = kron(-1*HIR*(eNR*eNR')*BSxR,IR);
        SATyL = kron(IL,-1*HIL*BSyL);
        SATyR = kron(IR,-1*HIR*BSyR);
        bigDL = bigD2xL+SATxL+bigD2yL+SATyL;
        bigDR = bigD2xR+SATxR+bigD2yR+SATyR;
        bigD = [bigDL big0LR; big0RL bigDR];
    end

    function S = Neum(t)
        S0 = kron(He0L,g0(yL,t));
        S1 = kron(HeNR,g1(yR,t));
        S2L = kron(g2L(xL,t),He0L);
        S2R = kron(g2R(xR,t),He0R);
        S3L = kron(g3L(xL,t),HeNL);
        S3R = kron(g3R(xR,t),HeNR);
        
        S = [S0+S2L-S3L; -S1+S2R-S3R];
    end        
    
    tauL = -gamma/(alph*hL);
    tauR = -gamma/(alph*hR);
    if boundType==1
        SATxL =         kron(BSxL'       *(e0L*e0L'),IL);
        SATxL = SATxL + kron(tauL*bL(xmin)*(e0L*e0L'),IL);
        SATxL = bigHIxL*SATxL;

        SATxR =         kron(BSxR'       *(eNR*eNR'),IR);
        SATxR = SATxR + kron(tauR*bR(xmax)*(eNR*eNR'),IR);
        SATxR = bigHIxR*SATxR;
        
        SATyL =         kron(IL,BSyL'        *(e0L*e0L'));
        SATyL = SATyL + kron(IL,tauL*cL(ymin)*(e0L*e0L'));
        SATyL = SATyL + kron(IL,BSyL'        *(eNL*eNL'));
        SATyL = SATyL + kron(IL,tauL*cL(ymax)*(eNL*eNL'));
        SATyL = bigHIyL*SATyL;

        SATyR =         kron(IR,BSyR'        *(e0R*e0R'));
        SATyR = SATyR + kron(IR,tauR*cR(ymin)*(e0R*e0R'));
        SATyR = SATyR + kron(IR,BSyR'        *(eNR*eNR'));
        SATyR = SATyR + kron(IR,tauR*cR(ymax)*(eNR*eNR'));
        SATyR = bigHIyR*SATyR;
       
        bigDL = bigD2xL+SATxL+bigD2yL+SATyL;
        bigDR = bigD2xR+SATxR+bigD2yR+SATyR;
        bigD = [bigDL big0LR; big0RL bigDR];
    end

    function S = Diri(t)
        xlow  = g0(yL,t);
        xhigh = g1(yR,t);
        S0xL = kron(BSxL'       *e0L,xlow );
        S1xL = kron(tauL*bL(xmin)*e0L,xlow );
        S2xR = kron(BSxR'       *eNR,xhigh);
        S3xR = kron(tauR*bR(xmax)*eNR,xhigh);
        
        Sx = bigbigHIx*[S0xL+S1xL; S2xR+S3xR];
        
        ylowL  = g2L(xL,t);
        yhighL = g3L(xL,t);
        S0yL = kron(ylowL ,BSyL'       *e0L);
        S1yL = kron(ylowL ,tauL*cL(ymin)*e0L);
        S2yL = kron(yhighL,BSyL'       *eNL);
        S3yL = kron(yhighL,tauL*cL(ymax)*eNL);
        SyL = S0yL+S1yL+S2yL+S3yL;
        
        ylowR  = g2R(xR,t);
        yhighR = g3R(xR,t);
        S0yR = kron(ylowR ,BSyR'       *e0R);
        S1yR = kron(ylowR ,tauR*cR(ymin)*e0R);
        S2yR = kron(yhighR,BSyR'       *eNR);
        S3yR = kron(yhighR,tauR*cR(ymax)*eNR);
        SyR = S0yR+S1yR+S2yR+S3yR;
        
        Sy = bigbigHIy*[SyL; SyR];
        S = Sx+Sy;
    end        
    
    %%Insert grid interface
    tau_i   = -5*(bL(xmid)+bR(xmid))/(4*alph*min([hL hR]));
    beta_i  = 0.5;
    gamma_i = -0.5;
    
    interLL =         + kron(tau_i  *HIL      *(eNL*eNL')     ,IL);
    interLL = interLL + kron(beta_i *HIL*BSxL'*(eNL*eNL')     ,IL);
    interLL = interLL + kron(gamma_i*HIL      *(eNL*eNL')*BSxL,IL);
    
    interLR =         + kron(tau_i  *HIL      *(eNL*-e0R')     ,polLR);
    interLR = interLR + kron(beta_i *HIL*BSxL'*(eNL*-e0R')     ,polLR);
    interLR = interLR + kron(gamma_i*HIL      *(eNL* e0R')*BSxR,polLR);
    
    interRL =         - kron(tau_i  *HIR      *(e0R*eNL')      ,polRL);
    interRL = interRL - kron(beta_i *HIR*BSxR'*(e0R*eNL')      ,polRL);
    interRL = interRL + kron(gamma_i*HIR      *(e0R*eNL')*BSxL ,polRL);
    
    interRR =         - kron(tau_i  *HIR      *(e0R*-e0R')     ,IR);
    interRR = interRR - kron(beta_i *HIR*BSxR'*(e0R*-e0R')     ,IR);
    interRR = interRR + kron(gamma_i*HIR      *(e0R* e0R')*BSxR,IR);
    
    bigD = bigD + [interLL interLR; interRL interRR];
    
    if eigTest
        val = (eig(full(bigD)));
        plot(real(val),imag(val),'*');
        return;
    end
    
    if stepType==0
        bigbig0 = sparse(bigbigN,bigbigN);
        bigIL = kron(IL,IL);
        bigIR = kron(IR,IR);
        bigbigI = [bigIL big0LR; big0RL bigIR];
        bigD = [bigbig0 bigbigI; bigD bigbig0];
        Nl = sparse(bigbigN,1);
    end
    
    function out = prim0(in,t)
        S = Neum(t);
        S = [Nl; S];
        out = bigD*in-S;
    end
    function out = bis0(in,t,dtSq)
        S = Neum(t);
        S_tt = -u_t^2*S;
        out = bigD*(in+dtSq/12*(bigD*in-S))-S-S_tt*dtSq/12;
    end
    function out = prim1(in,t)
        S = Diri(t);
        S = [Nl; S];
        out = bigD*in-S;
    end
    function out = bis1(in,t,dtSq)
        S = Diri(t);
        S_tt = -u_t^2*S;
        out = bigD*(in+dtSq/12*(bigD*in-S))-S-S_tt*dtSq/12;
    end

    prim = 0;
    bis = 0;
    if boundType==0
        prim = @prim0;
    end
    if boundType==1
        prim = @prim1;
    end
    if boundType==0
        bis = @bis0;
    end
    if boundType==1
        bis = @bis1;
    end
    
    %%%%% Looping
    if stepType==0
        [v,mov,movTArr] = primStep(v,dt,M,prim,t,mov,movDt,bigbigN);
    end
    if stepType==1
        [v,mov,movTArr] = bisStep(v,v_prev,dt,M,bis,t,mov,movDt,bigbigN);
    end
    
    %%%%%%% Printing
    if L2Test
        movL2 = zeros(1,movN);
        for ii = 1:movN
            L2normL = L2(mov(        1 :bigNL ,ii),f(xL,yL,movTArr(ii)),hL);
            L2normR = L2(mov((bigNL+1):bigbigN,ii),f(xR,yR,movTArr(ii)),hR);
            movL2(ii) = sqrt(L2normL^2+L2normR^2);
        end
        plot(linspace(0,tEnd,movN),movL2);
    end
    
    if movN && not(L2Test)
        if errTest
            for ii = 1:movN
                mov(1:bigNL,ii) = mov(1:bigNL,ii)-f(xL,yL,movTArr(ii));
                mov((bigNL+1):bigbigN,ii) = mov((bigNL+1):bigbigN,ii) ...
                    - f(xR,yR,movTArr(ii));
            end
        end
        
        movMax = max(max(mov));
        movMin = min(min(mov));
        for ii = 1:movN
            pause(movTime/movN);
            frameL = reshape(mov(       1 :bigNL  ,ii),[NL+1 NL+1]);
            frameR = reshape(mov((bigNL+1):bigbigN,ii),[NR+1 NR+1]);
            surf(xL,yL,frameL);
            hold on;
            surf(xR,yR,frameR);
            hold off;
            axis([xmin xmax ymin ymax movMin movMax]);
            caxis([movMin movMax]);
        end
    end
    
    L2normL = L2(v(        1 :bigNL ),f(xL,yL,tEnd),hL);
    L2normR = L2(v((bigNL+1):bigbigN),f(xR,yR,tEnd),hR);

    L2norm = sqrt(L2normL^2+L2normR^2);
end